Для начала следует обратить внимание на то, как вообще устроен интернет и что он есть такое.
Интернет являет собой структурыую основу для функционирования Всемирной Паутины (World Wide Web) и технически представляет собой множество взаимосвязанных
вычислительных устройств - компьютеров. Также встречается определение, согласно которому интернет представляет собой способ связи распределённых компьютеров
в единую сеть. В сильно упрощённой форме можно функционально подразделить компьютеры на: пользовательские устройства, маршрутизаторы, модемы или роутеры, серверы.
Через пользовательские устройства клиенты получают доступ к данным, маршрутизаторы предназначены для точечной предачи данных между двумя и более устройствами
и упрощения связи между двумя и более устройствами, модемы или роутеры служат для кодирования/декодирования передаваемой информации, а сервера предоставляют техническую
основу для функционирования веб-сайтов и/или баз данных. Виды связи между устройствами можно подразделить на проводные и беспроводные.
Web, в свою очередь, представляет собой распределённую систему доступа к взаимосвязанным документам, в основном представленным в гипертекстовом формате (HTML).

Таким образом сильно упрощённое прближение к тому, что происходит, в случае если набрать в поисковой строке браузера http://random_search.com следующее:
с нашего пользовательского устройства при помощи устройства кодирования/декодирования данных (модема или роутера) через наш маршрутизатор будет отправлен запрос
на некий ресурс, которым располагает поисковая система, используемая нашим браузером; после того, как запрос придёт на ресурс, в зависимости его успешности, по
обратномупути будет отправлен ответ, зачастую в виде гипертекстовых документов, которые затем наш браузер проинтерпретирует и выведет на экран пользовательского
устройства в человекочитаемом виде. 

Для теоретического описания того, как это работает, то есть передачи данных через сеть связи зачастую используется модель OSI - Open Systems Interconnection model - 
 - Модель взаимодействия открытых систем. Это концептуальная модель удалённой передачи данных, созданная в конце 1970-х. Как правило, в чистом виде она 
 не используется на практике, а применяется скорее для описания происходящего в сети. Модель OSI является 7-уровневой и включает следующие уровни (по возрастанию):
 1 - Физический (биты) (USB...) (Сетевое оборудование)
 2 - Канальный (фреймы) (PPP, IEEE...) (Endpoints, коммутаторы)
 3 - Сетевой (пакеты) (IPv4, IPv6...) (маршрутизаторы)
 4 - Транспортный (сегменты, датаграммы) (TCP, UDP) (хосты, межсетевые экраны)
 5 - Сеансовый (данные) (RPC, gRPC...) (хосты, межсетевые экраны)
 6 - уровень Представлений (данные) (ASCII, SSL...) (хосты, межсетевые экраны)
 7 - уровень Приложений (данные) (HTTP, HTTPS, FTP...) (хосты, межсетевые экраны)
 При передаче данных с одного устройства на другое сначала происходит их поуровневая нисходящая инкапсуляция и преобразование данных в конечном итоге в биты на физическом уровне,
 а затем также поуровневая восходящая декапсуляция с преобразованием данных в "человекочитаемый" вид на уровне приложений.

 Для программной и аппаратной практической реализации связи между устройствами и передачи данных между ними используется стек протоколов TCP/IP - 
  - Transmission Control Protocol/Internet Protocol - протокол упраления передачей/интернет протокол. Данный стек протоколов был разработан примерно в те же сроки,
 что и модель OSI. Однако он был аппаратно имплементирован раньше, был ближе к реалиям и получил большую поддержку.
 В рамках TCP/IP TCP отвечает за данные, управляет их отправкой и следит, чтобы данные были доставлены получателю. IP отвечает за связь между устройствами и
 разбиение информации на пакеты. Протокол TCP/IP 4-уровневый и включает следующие (по возрастанию) уровни:
 1 - Уровень сетевого доступа или канальный уровень (соответствует физическому и канальному уровням OSI)
 2 - Уровень сети интернет (соответствует сетевому уровню OSI)
 3 - Транспортный уровень (соответствует транспортному уровню OSI)
 4 - Уровень приложений (соответствует сеансовому, представлений, приложений уровням OSI)

Также существует множество иных протоколов передачи данных, типа UDP - передача датаграмм, FTP - передача файлов и т.д. В рамках осуществления запросов в Python
нам в первую очередь интересны следующие:
HTTP - hyper text transfer protocol - протокол передачи гипертекста прикладного уровня (по OSI).
HTTPS - HTTP с поддержкой шифрования.
Передача данных осуществляется при помощи запросов на ресурс - requests и получения ответов от ресурса - responses.

Структура HTTP запроса:

GET/URI/HTTP/1.1
HOST: date.org

или

ТИП ЗАПРОСА/Идентификатор запроса/Используемая версия протокола HTTP
Домен, на котором находится ресурс

Структура HTTP ответа:

HTTP/1.1 200 OK
Content-Type: application/json
<Body response>

или

Используемая версия протокола HTTP/Статус-код HTTP ответа
Headers (к примеру тип возвращаемого контента, информация о запросе и т.д.)
<Тело ответа>

Для того, чтобы запрос направлялся к какому-либо конкретному ресурсу, необходимо указать идентификатор этого ресурса - URI.
URI - Uniform Resourse Identifier - Унифицированный Идентификатор Ресурса
URL - Uniform Resourse Locator - Унифицированное Расположение (локация, локализатор...) Ресурса 
URN - Uniform Resourse Name - Унифицированное Имя Ресурса
URL и URN - разновидности URI.
Структура URI - это некоторый протокол формирования URI и в него входят:
1 - схема. Говорит о том, каким именно образом получить доступ к ресурсу. Прмеры: HTTP, FTP...
2 - домен. Уникальное имя ресурса.
3 - путь. Показывает, где именно на сервере расположен искомый ресурс.
4 - запрос - может включать дополнительные параметры (data, params...).
5 - фрагмент - может включать дополнительные параметры.
Обычно работа осуществляется с URL. Пример структуры URL:
http://site.com/hello/user?a=2&b=3#fragment
схема://домен/путь?запрос#фрагмент

Основные типы запросов:
GET - запрашивает представление ресурса. С помощью этого метода можно только получать данные.
POST - используется для отправки некоторых сущностей к определённому ресурсу. Часто вызывает некие изменения или побочные эффекты на сервере.
HEAD - запрашивает ресурс так же, как метод GET, но без тела ответа.
PUT - заменяет все текущие представления данными запроса.
DELETE - удаляет указанный запрос.
CONNECT - устанавливает "туннель" к серверу, определённому по ресурсу.
OPTIONS - используется для описания параметров соединения с ресурсом.
TRACE - выполняет вызов возвращаемого тестового сообщения с ресурса.
PATCH - используется для частичного изменения ресурса.

Типы запросов можно классифицировать в том числе и по идемпотентности.
Идемпотентность (применительно к запросам) - это свойство, которое означает, что повторный идентичный запрос, сделанный один или несколько
раз подряд, имеет один и тот же эффект, не изменяющий состояние сервера.
К примеру, корректно реализованные методы GET, PUT, DELETE - идемпотентны. POST - нет.
Классификация по кэшированию - GET и POST могут быть кэшируемыми, PUT и DELETE - нет.

HTTP статус-коды:
1хх - информационные
2хх - успешные
3хх - перенаправление
4хх - ошибка клиента
5хх - ошибка сервера

В Python для работы с запросами можно использовать встроенный модуль urlib, содержащий 4 подмодуля:
1 - request - работа с URL-запросами
2 - erorr - работа с исключениями
3 - parse - анализ URL-адресов
4 - robotparser - анализ robots.txt файлов

Однако на практике зачастую используется устанавливаемая библиотека requests, которая работает через "подкапотное" использование встроенного модуля urlib.
Библиотека requests поддерживает все вышеперечисленные типы запросов (get,post,put,patch,delete,head,connect,trace), а также имеет некоторые дополнительные
возможности, например session.
Предположительно (точная информация не найдена) в случае с requests каждый метод запроса перед непосредственной отправкой инкапсулируется в виде объекта
в соответствии с поведенческим GoF-паттерном - Command - Команда. Это должно позволять ставить их в очередь, логировать, отменять, изменять и т.д.
То есть, каждый метод запроса предположительно можно воспринимать как конструктор экземпляра класса.
Наиболее часто используемыми методами являются GET и POST.

1 - GET. Сигнатура метода:
get(url,params=None,allow_redirects=True,auth=None,cert=None,cookies=None,headers=None,proxies=None,stream=False,timeout=None,verify=True)
url - единственный обязательный параметр. Принимает тот url, по которому мы хотим осуществить запрос.
params - принимает словарь, список кортежей или объект bytes - указываются дополнительные параметры запроса.
allow_redirects - принимает True или False и указывает на то, осуществлять ли перенаправление с указанного url или нет. По умолчанию - True.
auth - принимает кортеж для уточнения определённой HTTP-аутентификации. По умолчанию - None.
cert - принимает строку или кортеж, определяющие файл сертификата или ключ. По умолчанию - None.
cookies - принимает словарь файлов cookie. По умолчанию - None.
headers - принимает словарь заголовков HTTP. По умолчанию - None.
proxies - принимает словарь для URL-адреса прокси.
stream - принимает логическое указание (True или False) в зависимости от которого ответ либо загружается целиком, либо передаётся в поточном режиме. По умолчанию - False.
timeout - принимает число или кортеж, указывающие сколько ждать до получения ответа. По умолчанию - None.
verify - принимает логическое указание, в зависимости от которого либо осуществляется проверка наличия сертификата TLS (Trancport Layer Security) на сервере, либо нет. По умолчанию - True.

2 - POST. Сигнатура метода:
post(url,data,json,files,...далее всё как в get-запросе)
url - единственный обязательный параметр. Принимает тот url, по которому мы хотим осуществить запрос.
data - аналог params в get-запросе.
json - объект JSON для отправки.
files - словарь файлов для отправки.

Сигнатура остальных методов по сути является подмножеством сигнатуры метода GET. Однако, стоит заметить, что все методы requests являют собой
высокоуровневую оболочку для requests.request(method, url, **kwargs), вызывая его "под капотом".
Также отдельного внимания заслуживает requests.session
3 - SESSION.
requests.session создаёт непрерывное соединение с ресурсом, в рамках которого сохраняются настройки, файды cookie и пул соединений.
session обычно используется в рамках контекстного менеджера with, который обеспечивает безопасное соединение.
Во время session можно использовать остальные методы requests.

Все методы requests возвращают одно и то же - объект requests.Response(), который обладает следующими свойствами и методами:
Свойства:
apparent_encoding - возвращает видимую кодировку
content - возвращает содержимое ответа в bytes
cookies - возвращает объект CookieJar с файлами cookie, отправленными с сервера
elapsed - возвращает время timedelta, обозначающее разность между получением ответа и моментом отправки
encoding - возвращает актуальную кодировку
headers - возвращает словарь с заголовками ответа
history - возвращает список объектов ответа, содержащих историю запросов
is_permanent_redirect - возвращает булево значение, которое обозначает представляет ли ответ постоянный перенаправленный адрес или нет
is_redirect - возвращает булево значение, которое обозначает был ли ответ перенаправлен или нет
links - возвращает ссылки заголовка
next - возвращает объект ReadedRequest для следующего запроса в перенаправлении
ок - возвращает True, если status-code ответа меньше 400
reason - возвращает текст, соответствующий коду состояния
status-code - возвращает HTTP status-code
text - возвращает содержимое ответа в Unicode
url - возвращает url ответа
request - возвращает объект запроса, запросивший этот ответ и response.request сам по себе также обладает многими свойствами (header, body, hooks и т.д.)
и является экземпляром класса requests.models.PreparedRequest

Методы:
close() - закрывает соединение с ресурсом
iter_content() - возвращает итератор ответа
iter_lines() - возвращает итератор строк ответа
json() - возвращает ответ в форме JSON, если ответ был записан в форме JSON или выдаёт ошибку
raise_for_status() - в случае возникновения ошибки возвращает HTTPError

Здесь стоит сказать, что requests представляет собой по сути библиотеку синхронных запросов, то есть использует блокирующий I/O - input/output.
GIL - Global Interpreter Block - Глобальная Блокировка Интерпретатора - это блокировка, которая позволяет только одному процессу управлять интерпретатором Python.
Таким образом только один процесс в некоторое время имеет право на выполнение байткода и, соответственно,параллельного выполнения программ в Python
не предусматривается в любом случае, если, конечно, одновременно функционирует только один интерпретатор.
GIL в целом нужен потому, что в Python поддерживается парадигма конкуретности (concurrency) задач и в эталонной реализации Python (CPython)
управление памятью осуществляется при помощи подсчёта ссылок, то есть удаления какой-либо сущности происходит при нулёвом счётчике ссылок на эту сущность.

Конкурентность - это способ выполнения задач, при котором может происходить запуск на выполнение сразу нескольких задач (не обязательно строго одновременно).
То есть, при последовательнсти задачи исполняются одна за одной: начата одна -> завершена одна, начата вторая -> завершена вторая и т.д.
А при конкурентности: запущена одна -> запущена вторая -> запущена третья -> выполнена (любая) -> запущена четвёртая -> ... -> выполнена последняя и т.д.
При параллельности (которая является разновидностью конкурентности) же: запущены все (сколько позволит ПО) одновременно, выполнены в зависимости от задачи и железа (ядер).

GIL вообще представляет собой реализацию одного из примитивов синхронизации, среди которых отдельно стоит выделить мьютексы, семафоры и спинлоки.
Мьютексы представляют собой блокировщики одновременного доступа нескольких потоков к элементам программы, которые не могут быть одновременно использованы
более, чем одним потоком.
Семафоры представляют собой блокировщики, которые функционируют на основе некоторого счётчика и которые блокируют доступ при недопустимых операциях декрементирования.
Спинлоки же представляют собой блокировщики, которые не позволяют получить доступ к элементам программы, которые не могут быть одновременно использованными
более, чем одним потоком при этом используя цикл активного ожидания.

Наличие GIL в Python означает, что если у нас выполняется некоторый запрос на удалённый ресурс, то вся остальная программа будет вынуждена ожидать, пока
выполнится этот запрос и только потом переходить к следующим своим фрагментам. И, если предположить, что у нас есть список из десяти (или миллиона)
запросов (или любых иных вычислений), то каждый последующий запрос должен будет ожидать завершения выполнения предыдущего и только после этого выполняться сам.
Так работает синхронное (последовательное) выполнение программ в Python за счёт GIL. И отсутствие поддержки параллельного выполнения программ является одной
из основных линий критики Python со стороны разработчиков. Однако, на именно такой подход есть веские причины - Python не поддерживает потокобезопасного
управления памятью.

Саму потокобезопасность можно определить, как возможность различных элементов программы быть использованными одновременно различными процессами без повреждения
данных или взаимоблокировки процессов. Ключевыми факторами потокобезопасности называют реентерабельность и линеаризуемость.
Реентерабельность это свойство программы, которое обеспечивает возможность одновременного доступа к элементам программы разными процессами и как минимум гарантирует
отсутствие ошибок.
Линеаризуемость это свойство программы, которое гарантирует, что результат её параллельного выполнения разными процессами эквивалентен некоторому последовательному
выполнению.

И, так как в Python эта самая потокобезопасность не гарантируется, то используется именно блокирующй тип, представляющий собой способ выполнения программы,
в контексте которого изначально завершается нечто одно и только потом начинается нечто иное. Однако, так как зачастую блокирующий способ несмотря на обеспечение
безопасной работы с данными, показывает слишком малую скорость работы, в Python имеются способы формирования неблокирующего (конкурентного) формата работы и основных
вариантов всего 3:
использование процессов,
использование потоков,
использование асинхронного выполнения.

Стандартные задачи же вообще можно подразделить на 2 типа:
CPU-bound - скорость выполнения которых зависит от вычислительной мощности используемого обородования. (CPU - central processing unit - центральное обрабатывающее устройство)
I/O-bound - скорость выполнения которых зависит от скорости поступления входных данных и отправки данных на выход.

Процесс представляет собой отдельную независимую область выполнения со своим пространством имён, памятью и ресурсами. Процессы являются "тяжёлыми" с точки зрения
использования ресурсов, памяти, коммуникации друг с другом и скорости работы. Процессы более подходят для задач, в которых требуется повышенная безопасность и
надёжность. В рамках одного процесса могут создаваться дополнительные потоки, которые называются дополнительными или фоновыми. в рамках обычной программы в
Python создаётся один процесс и, в его рамках, один главный поток. Количество процессов, которые можно запустить параллельно на компьютере ограничено количеством
ядер CPU.
Возможность использования процессов в Python предоставляет встроенный модуль multiprocessing. Этот модуль может эффективно использоваться для любого типа задач.

Потоки представляет собой подзадачи внутри одного процесса и имеют общую память, ресурсы и пространство имён. Потоки легковесны, требуют меньше ресурсов и памяти,
а также способны осуществлять коммуникацию друг с другом и функционируют быстрее, чем отдельные процессы. Потоки обычно используются там, где нужна скорость
исполнения и быстрый обмен данными. Также поток является наименьшей единицей выполнения, имеющей право управлять операционной системой. Количество создаваемых
потоков теоретически не ограничено, но слишком большое их количество также не является продуктивным, ведь в рамках каждого процесса одновременно может работать
только один поток.
Возможность использования потоков в Python предоставляет встроенный модуль threading, который предпочитительно использовать для задач типа I/O-bound.

Для работы с асинхронным I/O в Python, начиная с версии 3.4 используется встроенный модуль asyncio, а в версии 3.5 были добавлены ключевые слова async/await,
которые представляют собой синтаксический сахар над синтаксисом генераторов. asyncio, также как и threading, предпочтительно использовать для I/O-bound задач.
Основой функционирования asyncio является event loop - цикл событий.
Цикл событий представляет собой некоторое связующее звено между поставщиками событий и их обработчиками. Он может быть представлен в виде "ленивого"
бесконечного цикла, который функционирует до тех пор, пока есть события. Конкретно в asyncio цикл событий управляет очередью задач.
Задача (task) представляет собой обёртку вокруг сопрограммы (coroutine).
Сопрограмма или "корутинная" функция - это функция, которая может приостанавливать своё выполнение, встретив I/O операцию, переходить к последующим участкам
программы и возвращаться к приостановленному участку. Такая функция возвращает объект coroutine (корутину).
То есть изначально создаётся пустой цикл событий, затем в него добавляются сопрограммы, обёрнутые в задачи. Цикл на каждой итерации проверяет, есть ли в очереди
готовые задачи, не ожидающие I/O и, если да, то они выполняются. 