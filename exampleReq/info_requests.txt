Для начала следует обратить внимание на то, как вообще устроен интернет и что он есть такое.
Интернет являет собой структурыую основу для функционирования Всемирной Паутины (World Wide Web) и технически представляет собой множество взаимосвязанных
вычислительных устройств - компьютеров. Также встречается определение, согласно которому интернет представляет собой способ связи распределённых компьютеров
в единую сеть. В сильно упрощённой форме можно функционально подразделить компьютеры на: пользовательские устройства, маршрутизаторы, модемы, серверы.
Через пользовательские устройства клиенты получают доступ к данным, маршрутизаторы предназначены для точечной предачи данных между двумя и более устройствами
и упрощения связи между двумя и более устройствами, модемы служат для кодирования/декодирования передаваемой информации, а сервера предоставляют техническую
основу для функционирования веб-сайтов и/или баз данных. Виды связи между устройствами можно подразделить на проводные и беспроводные.
Web, в свою очередь, представляет собой распределённую систему доступа к взаимосвязанным документам, в основном представленным в гипертекстовом формате.

Для теоретического описания передачи данных через сеть связи зачастую используется модель OSI - Open Systems Interconnection model - 
 - Модель взаимодействия открытых систем. Это концептуальная модель удалённой передачи данных, созданная в конце 1970-х. Как правило, в чистом виде она 
 не используется на практике, а применяется скорее для описания происходящего в сети. Модель OSI является 7-уровневой и включает следующие уровни (по возрастанию):
 1 - Физический (биты) (USB...) (Сетевое оборудование)
 2 - Канальный (фреймы) (PPP, IEEE...) (Endpoints, коммутаторы)
 3 - Сетевой (пакеты) (IPv4, IPv6...) (маршрутизаторы)
 4 - Транспортный (сегменты, датаграммы) (TCP, UDP) (хосты, межсетевые экраны)
 5 - Сеансовый (данные) (RPC, gRPC...) (хосты, межсетевые экраны)
 6 - уровень Представлений (данные) (ASCII, SSL...) (хосты, межсетевые экраны)
 7 - уровень Приложений (данные) (HTTP, HTTPS, FTP...) (хосты, межсетевые экраны)
 При передаче данных с одного устройства на другое сначала происходит их поуровневая нисходящая инкапсуляция и преобразование данных в конечном итоге в биты на физическом уровне,
 а затем также поуровневая восходящая декапсуляция с преобразованием данных в "человекочитаемый" вид на уровне приложений.

 Для программной и аппаратной практической реализации связи между устройствами и передачи данных между ними используется стек протоколов TCP/IP - 
  - Transmission Control Protocol/Internet Protocol - протокол упраления передачей/интернет протокол. Данный стек протоколов был разработан примерно в те же сроки,
 что и модель OSI. Однако он был аппаратно имплементирован раньше, был ближе к реалиям и получил большую поддержку.
 В рамках TCP/IP TCP отвечает за данные, управляет их отправкой и следит, чтобы данные были доставлены получателю. IP отвечает за связь между устройствами и
 разбиение информации на пакеты. Протокол TCP/IP 4-уровневый и включает следующие (по возрастанию) уровни:
 1 - Уровень сетевого доступа или канальный уровень (соответствует физическому и канальному уровням OSI)
 2 - Уровень сети интернет (соответствует сетевому уровню OSI)
 3 - Транспортный уровень (соответствует транспортному уровню OSI)
 4 - Уровень приложений (соответствует сеансовому, представлений, приложений уровням OSI)

Также существует множество иных протоколов передачи данных, типа UDP - передача датаграмм, FTP - передача файлов и т.д. В рамках осуществления запросов в Python
нам в первую очередь интересны следующие:
HTTP - hyper text transfer protocol - протокол передачи гипертекста прикладного уровня (по OSI).
HTTPS - HTTP с поддержкой шифрования.
Передача данных осуществляется при помощи запросов на сервер - requests и получения ответов от сервера - responses.

Структура HTTP запроса:

GET/URI/HTTP/1.1
HOST: date.org

или

ТИП ЗАПРОСА/Идентификатор запроса/Используемая версия протокола HTTP
Домен, на котором находится ресурс

Структура HTTP ответа:

HTTP/1.1 200 OK
Content-Type: application/json
<Body response>

или

Используемая версия протокола HTTP/Статус-код HTTP ответа
Headers (к примеру тип возвращаемого контента, информация о запросе и т.д.)
<Тело ответа>

Для того, чтобы запрос направлялся к какому-либо конкретному ресурсу, необходимо указать идентификатор этого ресурса - URI.
URI - Uniform Resourse Identifier - Унифицированный Идентификатор Ресурса
URL - Uniform Resourse Locator - Унифицированное Расположение (локация, локализатор...) Ресурса 
URN - Uniform Resourse Name - Унифицированное Имя Ресурса
URL и URN - разновидности URI.
Структура URI - это некоторый протокол формирования URI и в него входят:
1 - схема. Говорит о том, каким именно образом получить доступ к ресурсу. Прмеры: HTTP, FTP...
2 - домен. Уникальное имя ресурса.
3 - путь. Показывает, где именно на сервере расположен искомый ресурс.
4 - запрос - может включать дополнительные параметры (data, params...).
5 - фрагмент - может включать дополнительные параметры.
Обычно работа осуществляется с URL. Пример структуры URL:
http://site.com/hello/user?a=2&b=3#fragment
схема://домен/путь?запрос#фрагмент


Основные типы запросов:
GET - запрашивает представление ресурса. С помощью этого метода можно только получать данные.
POST - используется для отправки некоторых сущностей к определённому ресурсу. Часто вызывает некие изменения или побочные эффекты на сервере.
HEAD - запрашивает ресурс так же, как метод GET, но без тела ответа.
PUT - заменяет все текущие представления данными запроса.
DELETE - удаляет указанный запрос.
CONNECT - устанавливает "туннель" к серверу, определённому по ресурсу.
OPTIONS - используется для описания параметров соединения с ресурсом.
TRACE - выполняет вызов возвращаемого тестового сообщения с ресурса.
PATCH - используется для частичного изменения ресурса.

Типы запросов можно классифицировать в том числе и по идемпотентности.
Идемпотентность (применительно к запросам) - это свойство, которое означает, что повторный идентичный запрос, сделанный один или несколько
раз подряд, имеет один и тот же эффект, не изменяющий состояние сервера.
К примеру, корректно реализованные методы GET, PUT, DELETE - идемпотентны. POST - нет.
Классификация по кэшированию - GET и POST могут быть кэшируемыми, PUT и DELETE - нет.


HTTP статус-коды:
1хх - информационные
2хх - успешные
3хх - перенаправление
4хх - ошибка клиента
5хх - ошибка сервера

В Python для работы с запросами можно использовать встроенный модуль urlib, содержащий 4 подмодуля:
1 - request - работа с URL-запросами
2 - erorr - работа с исключениями
3 - parse - анализ URL-адресов
4 - robotparser - анализ robots.txt файлов

Однако на практике зачастую используется устанавливаемая библиотека requests, которая работает через "подкапотное" использование встроенного модуля urlib.
Библиотека requests поддерживает все вышеперечисленные типы запросов (get,post,put,patch,delete,head,connect,trace), а также имеет некоторые дополнительные возможности,
например session.
Предположительно (точная информация не найдена) в случае с requests каждый метод запроса перед непосредственной отправкой инкапсулируется в виде объекта
в соответствии с поведенческим GoF-паттерном - Command - Команда. Это должно позволять ставить их в очередь, логировать, отменять, изменять и т.д.
То есть, каждый метод запроса предположительно можно воспринимать как конструктор экземпляра класса.
Наиболее часто используемыми методами являются GET и POST.

1 - GET. Сигнатура метода:
get(url,params=None,allow_redirects=True,auth=None,cert=None,cookies=None,headers=None,proxies=None,stream=False,timeout=None,verify=True)
url - единственный обязательный параметр. Принимает тот url, по которому мы хотим осуществить запрос.
params - принимает словарь, список кортежей или объект bytes - указываются дополнительные параметры запроса.
allow_redirects - принимает True или False и указывает на то, осуществлять ли перенаправление с указанного url или нет. По умолчанию - True.
auth - принимает кортеж для уточнения определённой HTTP-аутентификации. По умолчанию - None.
cert - принимает строку или кортеж, определяющие файл сертификата или ключ. По умолчанию - None.
cookies - принимает словарь файлов cookie. По умолчанию - None.
headers - принимает словарь заголовков HTTP. По умолчанию - None.
proxies - принимает словарь для URL-адреса прокси.
stream - принимает логическое указание (True или False) в зависимости от которого ответ либо загружается целиком, либо передаётся в поточном режиме. По умолчанию - False.
timeout - принимает число или кортеж, указывающие сколько ждать до получения ответа. По умолчанию - None.
verify - принимает логическое указание, в зависимости от которого либо осуществляется проверка наличия сертификата TLS (Trancport Layer Security) на сервере, либо нет. По умолчанию - True.

2 - POST. Сигнатура метода:
post(url,data,json,files,...далее всё как в get-запросе)
url - единственный обязательный параметр. Принимает тот url, по которому мы хотим осуществить запрос.
data - аналог params в get-запросе.
json - объект JSON для отправки.
files - словарь файлов для отправки.

Сигнатура остальных методов по сути является подмножеством сигнатуры метода GET. Однако, стоит заметить, что все методы requests являют собой
высокоуровневую оболочку для requests.request(method, url, **kwargs), вызывая его "под капотом".
Также отдельного внимания заслуживает requests.session
3 - SESSION.
requests.session создаёт непрерывное соединение с ресурсом, в рамках которого сохраняются настройки, файды cookie и пул соединений.
session обычно используется в рамках контекстного менеджера with, который обеспечивает безопасное соединение.
Во время session можно использовать остальные методы requests.

Все методы requests возвращают одно и то же - объект requests.Response(), который обладает следующими свойствами и методами:
Свойства:
apparent_encoding - возвращает видимую кодировку
content - возвращает содержимое ответа в bytes
cookies - возвращает объект CookieJar с файлами cookie, отправленными с сервера
elapsed - возвращает время timedelta, обозначающее разность между получением ответа и моментом отправки
encoding - возвращает актуальную кодировку
headers - возвращает словарь с заголовками ответа
history - возвращает список объектов ответа, содержащих историю запросов
is_permanent_redirect - возвращает булево значение, которое обозначает представляет ли ответ постоянный перенаправленный адрес или нет
is_redirect - возвращает булево значение, которое обозначает был ли ответ перенаправлен или нет
links - возвращает ссылки заголовка
next - возвращает объект ReadedRequest для следующего запроса в перенаправлении
ок - возвращает True, если status-code ответа меньше 400
reason - возвращает текст, соответствующий коду состояния
status-code - возвращает HTTP status-code
text - возвращает содержимое ответа в Unicode
url - возвращает url ответа
request - возвращает объект запроса, запросивший этот ответ.

response.request сам по себе также обладает многими свойствами (header, body, hooks и т.д.) и является экземпляром класса requests.models.PreparedRequest

Методы:
close() - закрывает соединение с ресурсом
iter_content() - возвращает итератор ответа
iter_lines() - возвращает итератор строк ответа
json() - возвращает ответ в форме JSON, если ответ был записан в форме JSON или выдаёт ошибку
raise_for_status() - в случае возникновения ошибки возвращает HTTPError